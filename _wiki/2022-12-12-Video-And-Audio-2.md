---
layout: wiki
title: 音视频压缩-基础概念（二）
cate1: Media
cate2:
description: 音视频压缩
keywords: Media, Compression
type:
link:
mermaid: false
sequence: false
flow: false
mathjax: false
mindmap: false
mindmap2: false
---
## 内容中的冗余越多，就能被压缩的越多

**将原始字符转换为更短的符号的表称为码本**。香农的研究生大卫 A 霍夫曼 发明了一种方法，用于给一套特定的内容（或是用于一个术语表）生成一个优化的码本。对将要压缩的东西越了解，生成的码本越好。

可以事先对码本取得一致，这样解码器知道如何最好地解码内容。可以使用多个码本，在文件开头使用一个代码，甚至在文件中改变代码提示使用了哪个码本。或者在文件压缩时动态地创建一个码本。

**“冗余越多压缩越好”反过来的说法是冗余越少越不好压缩。真正随机的数据完全不能被压缩；对任意给定的数字没有更大的可能性，所以没有有用的霍夫曼码本。因此码本加上压缩后的数据会比原始数据更大。如今的压缩人士不对这种数据进行压缩，所以输出的文件不会比输入文件更大。**

### 编码效率越高，输出的随机性越大
利用码本，减少冗余使文件更小。因为冗余越少，根据定义用于数据本身的样式越少，因此数据本身显得随意。你看一下文本开头的十几个字符，便能马上看出是什么语言。看一个压缩后的文件开头的十几个字符，你完全不知道它是什么。

## 数据压缩
数据压缩是对任意内容的压缩。如计算机文件，事先不必对其内容有多少了解。

### 压缩良好的数据不能良好压缩
如前所述，有效编码后的文件看起来非常随机。这意味如果最初的压缩实现得很好，那就没有进一步压缩的空间。所有的现代编解码器已经把数据压缩作为整个压缩处理的一部分，所以压缩后的格式，如 MP3 和 H.264 ，是不能被进一步压缩的典型。大的例外是创建格式，尤其是未压缩的格式。利用未压缩的视频，你可以得到 2:1 的压缩，或者一个帧内编解码器中几个成排的帧完全一样。

一个由来以久的互联网花招/恶作剧是，压缩算法能够降低随机数据的大小，甚至它自己的输出。信息论证明了这样的系统全都是空话。

### 多用途的压缩不理想
为每一个压缩文件生成一个码本要耗费时间，扩展文件大小，增加用于压缩的时间。**理想状态下，一个压缩技术能够适应它获得的数据结构**。这就是为什么无损图片压缩典型地让压缩后的文件在一定程度上比在相同的未压缩源文件上使用数据压缩得到的文件更小，并且压缩快得多。我们在文本压缩例子中能够看到相同的事情发生。

#### 压缩小增长需要压缩时间大增长
**一个给定的文件能够被压缩到多小有一个基本的极限，称为香农极限**。对于随机数据，这个极限的大小和源文件一样。对于高度冗余的数据，这个极限可以非常小。一个由重复几百万次的“01010101”样式组成的文件，可被压缩到原始数据的非常小的百分比。但是，现实世界中的应用程序不会想尽办法到达香农极限，因为这需要极大数量的计算机马力，文件较大尤其如此。大多数压缩应用程序在编码速度和压缩效率之间有一个权衡控制。本质上，这些控制扩展了任意时刻检查的文件的总量，以及被搜索用于匹配的码本的大小。然而，压缩时间加倍并不会把文件大小砍掉一半。压缩时间加倍可能只能让你更靠近文件的香农极限几个百分点。让文件更小10个百分点可能需要超过10倍的压缩时间，甚至可能筋疲力尽。

有损和无损压缩

> **无损压缩编解码器保留了原始文件中的所有信息。另一方面，有损编解码器在压缩过程中丢弃了原始文件中包含的一些数据。有些编辑码，如 PNG，总是无损的。而像 VC-1 则总是有损的。另一些编解码器可能有损也可能无损，这取决于如何设置质量和数据率。根据定义，无损算法可能不能把文件压缩得更小一点。有损编解码器通常让你指定你的目标数据率，然后丢弃足够的信息来满足目标数据率。这实际上只对媒体有意义-我们不希望一首诗被压缩后出来的是不同的字词！**

## 空间压缩基础
空间压缩构成了所有视频压缩的基础。

空间压缩从自然颜色空间的未压缩源开始，典型的是每个通道 8-bit 的 4:2:0 。每个通道典型地对它自己压缩，所以你可以认为它是并行压缩的 3 个独立的 8-bit 位图。简单起见，我主要讨论单通道压缩，因此是灰阶（只有 Y'）影像。

### 空间压缩方法
大多数现代视频编解码器采用**离散余弦变化**（Discrete Cosine Transformation, DCT）用于图像。

#### 行程编码
用于压缩图像数据的最简单的技术就是行程编码（Run-Length Encoding, RLE）。**本质上，数据存储为一系列的成对数字，第一个给出序列的颜色，第二个指示这一行应该有多少个像素**。RLE 处理照片等自然影像时很糟糕。轻微数量的随机噪声就能导致影像和未压缩的文件一样大，因为只要每个像素与它相邻像素有稍许不同，那么就不会有任何的水平行具有相同的值。对于看上去简单的“0101010”这种重复样式，RLE 也完全不能压缩这个文件，因为在一排中根本没有超过一个相同的数值。

#### 采用 LZ77 和 LZW 的高级无损压缩
数据结构的可预测性越大，压缩的效率就越大。

第一个高压缩的文件格式是基于 LZ77（Lempel Ziv 1977）或 LZW（Lempel-Ziv-Welch）算法。它们本质上都是高级 RLE 和 霍夫曼编码的组合。**两者在运行时都建立了一个码本，然后寻找相同符号的重复串，并且也指派那些代码**。

LZW 被 Adobe 公司用于 TIFF，被 CompuServe 公司用于 GIF。两者都是从左上角开始然后一个像素接一个像素进行编码。

PNG 图像格式是基于较老的 LZ77 的一种图像格式。PNG 提供了比基于 LZW 的编解码器好得多的压缩，不是因为基本压缩算法的效率好得多，而是因为这种格式支持无损过滤用于更好地安排图像数据，达到更有效率的压缩。特别的是，**每一行上的每个像素可以被描述为与其上方的像素、左边的像素的差别，或者这两个像素的平均**。这一点不同于依赖相同像素的 RLE，PNG 于是能够用一些比特对轻微的差异进行编码。同时结果样式本身也能具有一些冗余度（在一条白线下的一条黑线全部具有相同的差别，所以最终的无损编码效率非常高）。

**这个优化数据结构使最终的无损编码更有效率的核心概念，是用于每一个发送编解码器中的重要的概念之一**。

#### 算术编码
无损技术：算术编码。使用传统的霍夫曼编码本，你所能期望的最好结果是每个符号用一个比特编码。但是每个符号要求一个整数的比特。**算术编码考虑每个符号的平均数的比特作为一个比特的一部分，反映它们的统计概率**。

算术编码允许更有效率的无算编码，能更加接近香农极限。

**用于无损压缩图像编码的最常用的算术编码是 Lagarith 编解码器**。和较老的 Huffyuv 无损编解码器相比，对典型的视频内容 Lagarith 可以有 30% 处理得更好，对较少噪声的内容也更好， Lagarith 通过的是：

 - 对每个通道独立进行编码（相邻的 Y' 值与相同像素的 Cb/Cr 值相比更为接近）。
 - 应用算术编码到结果。

无损图像压缩还不足以让我们达到我们需要的视频应用。

#### 离散余弦变换（DCT）

待续。。。

